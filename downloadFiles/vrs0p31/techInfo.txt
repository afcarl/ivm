








 model = ivm(X, y, kernelType, noiseType, selectionCriterion, d)

 ivm3dPlot(model, plotType, iter, X, y)

 model = ivmAddPoint(model, i)

 g = ivmApproxGradX(model, x, m, beta);

 g = ivmApproxLogLikeKernGrad(model)

 L = ivmApproxLogLikelihood(model);

 delta = ivmComputeInfoChange(model, add)

 ivmContour(X, Y, Z, lineWidth)

 g = ivmCovarianceGradient(invK, m)

 [kern, noise, ivmInfo] = ivmDeconstruct(model, fileName)

 ivmDisplay(model)

 model = ivmDowndateM(model, index)

 model = ivmDowndateNuG(model, index)

 model = ivmDowndateSites(model, index)

 model = ivmEpOptimise(model, prior, display, innerIters, ...
% 			     outerIters, optimiseNoise);

 model = ivmEpUpdateM(model, index)

 model = ivmEpUpdatePoint(model, i)

 g = ivmGradX(model, x, y);

 model = ivmInit(model, d)

 g = ivmKernelGradient(params, model)

 f = ivmKernelObjective(params, model)

 L = ivmLikelihoods(model, x, y);

 [X, y, XTest, yTest] = ivmLoadData(dataset)

 L = ivmLogLikelihood(model, x, y);

 [X, Y, Z, varZ] = ivmMeshVals(model, limx, limy, number)

 g = ivmNegGradientNoise(params, model)

 e = ivmNegLogLikelihood(params, model)

 model = ivmOptimise(model, options);

 model = ivmOptimiseIVM(model, display)

 model = ivmOptimiseKernel(model, display, iters);

 model = ivmOptimiseNoise(model, display, iters);

 options = ivmOptions(varargin)

 y = ivmOut(model, x);

 [gmu, gsigmavar] = ivmPosteriorGradMeanVar(model, X);

 [mu, varsigma] = ivmPosteriorMeanVar(model, X);

 model = ivmReconstruct(kern, noise, ivmInfo, X, y)

 model = ivmRun(XTrain, yTrain, kernelType, noiseType, ...
% 			selectionCriterion, dVal, options, kernelTieStructure, noiseTieStructure)

 [indexSelect, infoChange] = ivmSelectPoint(model, add);

 model = ivmSelectPoints(model, display)

 ivmSelectVisualise(model, display, k, dataIndexSelect)

 ivmTwoDPlot(model, iter, X, y)

 model = ivmUpdateM(model, index)

 model = ivmUpdateNuG(model, index)

 model = ivmUpdateSites(model, index)

